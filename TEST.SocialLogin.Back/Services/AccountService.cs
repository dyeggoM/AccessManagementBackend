using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Net.Http;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using Google.Apis.Auth;
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using TEST.SocialLogin.Back.Data;
using TEST.SocialLogin.Back.Entities;
using TEST.SocialLogin.Back.Interfaces;

namespace TEST.SocialLogin.Back.Services
{

    /// <summary></summary>
    public class AccountService : IAccountService
    {
        private UserManager<ApplicationUser> _userManager { get; }
        private SignInManager<ApplicationUser> _signInManager { get; }
        private readonly IHostEnvironment _env;
        private readonly IConfiguration _configuration;
        private readonly IEmailService _emailService;
        private readonly ILogger<AccountService> _logger;
        private readonly ApplicationContext _context;

        /// <summary></summary><param name="env"></param><param name="configuration"></param><param name="emailService"></param><param name="logger"></param><param name="userManager"></param><param name="signInManager"></param><param name="context"></param>
        public AccountService(IHostEnvironment env, IConfiguration configuration, IEmailService emailService, ILogger<AccountService> logger, UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager, ApplicationContext context)
        {
            _env = env;
            _configuration = configuration;
            _emailService = emailService;
            _logger = logger;
            _userManager = userManager;
            _signInManager = signInManager;
            _context = context;
        }

        /// <summary>
        /// Logs an error with a specific format.
        /// </summary>
        /// <param name="e">Exception to log.</param>
        /// <param name="methodName">Method name to log.</param>
        private void LogErrors(Exception e, string methodName)
        {
            _logger.Log(LogLevel.Error, $"{nameof(AccountService)}.{methodName}: {e.Message}");
            _logger.Log(LogLevel.Error, $"{nameof(AccountService)}.{methodName}: {e.InnerException}");
        }


        /// <summary>
        /// This method validates if the token received from Facebook was generated by the application.
        /// </summary>
        /// <param name="model"></param>
        /// <returns></returns>
        public async Task<ConfigExternalProviderDataDTO> ValidateFacebookToken(DTOExternalProviderLogin model)
        {
            try
            {
                var appId = _configuration[$"{model.Provider}:AppId"];
                var appSecret = _configuration[$"{model.Provider}:AppSecret"];
                using (var client = new HttpClient())
                {
                    if (!(await client.GetAsync($"https://graph.facebook.com/debug_token?input_token={model.IdToken}&access_token={appId}|{appSecret}")).IsSuccessStatusCode)
                        return null;
                }
                using (var client = new HttpClient())
                {
                    var result = await client.GetAsync($"https://graph.facebook.com/me?fields=first_name,last_name,email&access_token={model.IdToken}");
                    if (!result.IsSuccessStatusCode)
                        return null;
                    return JsonConvert.DeserializeObject<ConfigExternalProviderDataDTO>(await result.Content.ReadAsStringAsync());
                }
            }
            catch (Exception e)
            {
                LogErrors(e, nameof(ValidateFacebookToken));
                return null;
            }
        }

        /// <summary>
        /// This method validates if the token received from Google was generated by the application.
        /// </summary>
        /// <param name="model"></param>
        /// <returns></returns>
        public async Task<ConfigExternalProviderDataDTO> ValidateGoogleToken(DTOExternalProviderLogin model)
        {
            try
            {
                var clientId = _configuration[$"{model.Provider}:ClientId"];
                var settings = new GoogleJsonWebSignature.ValidationSettings()
                {
                    Audience = new List<string>() { clientId }
                };
                var payload = await GoogleJsonWebSignature.ValidateAsync(model.IdToken, settings);
                if (payload == null)
                    return null;
                return new ConfigExternalProviderDataDTO()
                {
                    Id = payload.Subject,
                    Email = payload.Email,
                    FirstName = payload.GivenName,
                    LastName = payload.FamilyName
                };
            }
            catch (Exception e)
            {
                LogErrors(e, nameof(ValidateGoogleToken));
                return null;
            }
        }

        /// <summary>
        /// This method generates a Bearer token to authenticate a logged user.
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        public string GenerateToken(ApplicationUser user)
        {
            try
            {
                var authClaims = new List<Claim>
                    {
                        new Claim(ClaimTypes.NameIdentifier, user.Id),
                        new Claim(ClaimTypes.Email, user.Email),
                        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                    };
                var token = new JwtSecurityToken(
                    //issuer: _configuration["ApiConfig:ValidIssuer"],
                    //audience: _configuration["ApiConfig:ValidAudience"],
                    notBefore: DateTime.UtcNow,
                    expires: DateTime.UtcNow.AddMinutes(2),
                    claims: authClaims,
                    signingCredentials: new SigningCredentials(new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["ApiConfiguration:Secret"])), SecurityAlgorithms.HmacSha256)
                );
                return new JwtSecurityTokenHandler().WriteToken(token);
            }
            catch (Exception e)
            {
                LogErrors(e, nameof(GenerateToken));
                return null;
            }
        }

        /// <summary>
        /// This method generates a random refresh token.
        /// </summary>
        /// <returns></returns>
        public string GenerateRefreshToken()
        {
            var randomNumber = new byte[32];
            using (var rng = System.Security.Cryptography.RandomNumberGenerator.Create())
            {
                rng.GetBytes(randomNumber);
                return Convert.ToBase64String(randomNumber);
            }
        }

        /// <summary>
        /// This method is used to retrieve the user information from an expired token.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        public ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
        {
            var tokenValidationParameters = new TokenValidationParameters
            {
                ValidateAudience = false, //you might want to validate the audience and issuer depending on your use case
                ValidateIssuer = false,
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["ApiConfiguration:Secret"])),
                ValidateLifetime = false //here we are saying that we don't care about the token's expiration date
            };
            var tokenHandler = new JwtSecurityTokenHandler();
            var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out var securityToken);
            var jwtSecurityToken = securityToken as JwtSecurityToken;
            if (jwtSecurityToken == null || !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase))
                throw new SecurityTokenException("Invalid token");
            return principal;
        }

        /// <summary>
        /// This method sends a verification email to the user.
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        public async Task<bool> SendEmailConfirmationToken(ApplicationUser user)
        {
            try
            {
                var emailDTO = new ConfigEmailDTO()
                {
                    From = _configuration["EmailConfiguration:User"],
                    FromName = "SocialLoginTest",
                    To = user.Email,
                    ToName = "",
                    Subject = "Verify Email",
                    IsHtml = false,
                    Body = await _userManager.GenerateEmailConfirmationTokenAsync(user)
                };
                var response = await _emailService.SendTextEmail(emailDTO);
                return response;
            }
            catch (Exception e)
            {
                LogErrors(e, nameof(SendEmailConfirmationToken));
                return false;
            }
        }

        /// <summary>
        /// Validates captcha
        /// </summary>
        /// <param name="token">Captcha token</param>
        /// <returns></returns>
        public async Task<bool> ValidateRecaptcha(string token)
        {
            using (var client = new HttpClient())
            {
                var secret = _configuration["Captcha:Secret"];
                var url = $"https://www.google.com/recaptcha/api/siteverify?secret={secret}+&response={token}";
                var result = await client.GetAsync(url);
                //var result = await client.GetAsync($"https://www.google.com/recaptcha/api/siteverify?secret={secret}+&response={token}");
                if (!result.IsSuccessStatusCode)
                    return false;
                var contentResult = result.Content.ReadAsStringAsync().Result;
                var res = JsonConvert.DeserializeObject<ConfigRecaptchaResponseDTO>(contentResult);
                if (!res.success)
                    return false;
                return res.score > 0.5;
            }
        }

        /// <summary>
        /// Validates existence of a user by its username
        /// </summary>
        /// <param name="userName">UserName to check.</param>
        /// <returns></returns>
        public async Task<bool> ValidateUserExistsByUserName(string userName)
        {
            return await _userManager.FindByNameAsync(userName) != null;
        }

        /// <summary>
        /// Validates existence of a user by its email
        /// </summary>
        /// <param name="email">Email to check.</param>
        /// <returns></returns>
        public async Task<bool> ValidateUserExistsByEmail(string email)
        {
            return await _userManager.FindByEmailAsync(email) != null;
        }

        /// <summary>
        /// Get user by its email
        /// </summary>
        /// <param name="email">User Email.</param>
        /// <param name="user">User found.</param>
        /// <returns></returns>
        public bool GetUserByEmail(string email, out ApplicationUser user)
        {
            user = _userManager.FindByEmailAsync(email).Result;
            return user != null;
        }

        /// <summary>
        /// Generates a hashed reset token for the specified user.
        /// </summary>
        /// <param name="user">User to generate reset token.</param>
        /// <returns></returns>
        public async Task<string> GenerateHashResetToken(ApplicationUser user)
        {
            var token = await _userManager.GeneratePasswordResetTokenAsync(user);
            return Convert.ToBase64String(Encoding.UTF8.GetBytes(token));
        }

        /// <summary>
        /// Creates a new user with the specified password and email.
        /// </summary>
        /// <param name="email">User email.</param>
        /// <param name="password">User password.</param>
        /// <param name="user">User generated.</param>
        /// <returns></returns>
        public bool CreateUser(string email, string password, out ApplicationUser user)
        {
            user = new ApplicationUser()
            {
                Email = email,
                SecurityStamp = Guid.NewGuid().ToString(),
                UserName = email,
            };
            return _userManager.CreateAsync(user, password).Result.Succeeded;
        }

        /// <summary>
        /// Confirms user email is being used.
        /// </summary>
        /// <param name="user">User to confirm.</param>
        /// <param name="confirmationToken">Confirmation Token.</param>
        /// <returns></returns>
        public async Task<bool> ConfirmUserEmail(ApplicationUser user, string confirmationToken)
        {
            return (await _userManager.ConfirmEmailAsync(user, confirmationToken)).Succeeded;
        }

        /// <summary>
        /// Validates if user has confirmed email.
        /// </summary>
        /// <param name="user">User to validate.</param>
        /// <returns></returns>
        public async Task<bool> ValidateUserEmailIsConfirmed(ApplicationUser user)
        {
            return await _userManager.IsEmailConfirmedAsync(user);
        }

        /// <summary>
        /// Validates if user has being locked out.
        /// </summary>
        /// <param name="user">User to validate.</param>
        /// <returns></returns>
        public async Task<bool> ValidateUserIsLockedOut(ApplicationUser user)
        {
            return await _userManager.IsLockedOutAsync(user);
        }

        /// <summary>
        /// Logs in a user
        /// </summary>
        /// <param name="user">User to login.</param>
        /// <param name="password">User password.</param>
        /// <param name="refreshToken">User Refresh token.</param>
        /// <returns></returns>
        public bool LoginUser(ApplicationUser user, string password, out string refreshToken)
        {
            refreshToken = GenerateRefreshToken();
            if (_userManager.CheckPasswordAsync(user, password).Result)
            {
                user.RefreshToken = refreshToken;
                try
                {
                    _context.SaveChanges();
                    return true;
                }
                catch (Exception e)
                {
                    LogErrors(e, nameof(LoginUser));
                    throw;
                }
            }
            return false;
        }

        /// <summary>
        /// Increments access fail count of user.
        /// </summary>
        /// <param name="user">User that failed to access.</param>
        /// <returns></returns>
        public async Task<bool> FailsUserAccess(ApplicationUser user)
        {
            return (await _userManager.AccessFailedAsync(user)).Succeeded;
        }

        /// <summary>
        /// Resets user password.
        /// </summary>
        /// <param name="user">User to modify password.</param>
        /// <param name="hashedResetToken">Hashed reset token.</param>
        /// <param name="newPassword">New user password.</param>
        /// <returns></returns>
        public async Task<bool> ResetUserPassword(ApplicationUser user, string hashedResetToken, string newPassword)
        {
            var resetToken = Encoding.Default.GetString(Convert.FromBase64String(hashedResetToken));
            return (await _userManager.ResetPasswordAsync(user, resetToken, newPassword)).Succeeded;
        }
    }
}
